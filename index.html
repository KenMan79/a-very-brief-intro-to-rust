<DOCTYPE html>
<html>
  <head>
    <title>a very brief intro to rust</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="public/skeleton.css" type="text/css" rel="stylesheet">
    <link href="public/custom.css" type="text/css" rel="stylesheet">
  </head>
  <body>
    <textarea id="source">

class: middle, center

![ferris](public/img/ferris.gif)
# A Very Brief Intro to Rust

---
class: middle, left

## Overview

* Rust, Cargo, Setup
* Concepts that are mostly the same as other languages
* Concepts that are different than in other languages
* Features that make Rust super awesome
* Concepts we didn't cover but that are things

---
class: middle, left

## What is Rust?

Rust is a systems programming language that runs blazingly fast, prevents
segfaults, and guarantees thread safety.

???

* Define "systems programming"
* Fast = as fast as C
* segfaults = crashing because of mismanaged memory
* Memory safety also covers buffer over/underflows

---
class: middle, left

## Rust Philosophy

* Favor explicit over implicit
* Zero-cost abstractions
* Only pay for what you use
* Memory safety
* Small standard library
* Error handling

???

* This does make it harder to prototype in Rust sometimes

---
class: middle, left

## What is Cargo?

* Package manager
* Build tool
* Test runner
* Documentation generator

???

* A lot of these things are convenience wrappers around other tools like rustc
* and rustdoc.

---
class: middle, left

## Setting up a Project

We're going to be making a *binary* project; the other option is a *library*.

`cargo new` will create a skeleton project setup for you.

1. `cd` to a directory where you like to store code
2. `cargo new --bin [projectname]`
3. `cd [projectname]`

If you use version control, now would be a good time to commit.

???

If you are writing a <strong>library</strong>, it means you intend for your
code to be used in someone else's application as a crate or module.

If you are writing a <strong>binary</strong>, it means that you'd like
to write code that compiles into a binary that someone can run. If you
want to do this, you need to use a `main.rs`. Inside the `main.rs` you
should have a `main` function.

---
class: middle, left

## Files created

- `Cargo.toml`: metadata about your project and its dependencies
- `.gitignore`: ignores compiled files built by Rust
- `src/main.rs`: where your Rust code goes

---
class: middle, left

## `src/main.rs`

```rust
fn main() {
    println!("Hello, world!");
}
```

???

* `fn` starts a function definition
* `main` is the name of the function
* `main` fn is special - entry point of your binary
* curly braces around the body
* `println!` is a macro (don't worry) that prints to the screen
* End lines with semicolons (mostly, we'll talk later)

---
class: middle, left

## Run it!

* `cargo run`
* Should print "Hello, world!"
* Now you have more files:
  * `target` directory: all the built stuff
  * `Cargo.lock`: locks your dependencies (we don't have any yet)
* Try printing out something else!
* Try printing out two things!

---
class: middle, left

## API Documentation

https://doc.rust-lang.org/
or
`rustup doc`

Click on "Standard Library API Reference"
or
`rustup doc --std`

---
class: middle, left

## Concepts that are mostly the same as other languages

---
class: middle, left

## Comments

* Double slash at the beginning of a line (`//`)
* Try commenting out one of your lines printing!
* There are other kinds of comments but this is the most common

---
class: middle, left

## Variables

```
let name = "ashley";
let age = 30;
println!("Hi, {}! You are {} years old.", name, age);
```

* Try making more variables and printing them all out in one `println!`

???

* `let`, variable name, single equals, value, semicolon.
* Crab pincers in println, then values that should fit in there

---
class: middle, left

## Experiment

What happens if you run this:

```
let apples = 100;
apples += 50;
println!("I have {} apples", apples);
```

???

* Have someone read the error message

---
class: middle, left

## Mutability

Variables are *immutable* by default in Rust.

```
let mut apples = 100;
apples += 50;
println!("I have {} apples", apples);
```

???

* Rust has functional influences
* Changing a value where you didn't expect to is a common source of bugs.

---
class: middle, left

## Types

Rust is strongly, statically typed. Common fundamental types are:

- `u32`: unsigned 32-bit integer
- `i32`: signed 32-bit integer
- `f64`: floating point number
- `String` and/or `&str`: more on these later
- `bool`: a boolean

---
class: middle, left

## Type inference

* Every value has a type that the compiler has to know about.
* Most of the time, the compiler can figure it out.
* Sometimes it can't, and you'll get an error and need to add an annotation.
* We could have written `let age: i32 = 30;`
* A place we **must** specify types is function definitions.

???

* Types come after the name

---
class: middle, left

## Functions

```rust
fn add_fifty(n: i32) -> i32 {
    n + 50
}

fn main() {
    println!("Lots: {}", add_fifty(100));
}
```

???

* Argument/parameter, named with type specified
* `->` plus return type, if returning a value
* No semicolon on the last line when returning that value
* No `return` keyword unless doing an early return
* Function call always uses parens, even if no arguments

---
class: middle, left

## Conditionals: `if`

```rust
fn main() {
    let age = 13u32;
    if n < 13 {
        println!("You may see G or PG movies");
    } else if n < 17 {
        println!("You may see G, PG, or PG-13 movies");
    } else {
        println!("You are old.");
        println!("You may see G, PG, PG-13, or R movies");
    }
}
```
???

* Shorthand for numeric type annotation
* Age can't be negative, compiler will make sure we don't have negative ages

---
class: middle, left

## Conditionals: `match`

Kinda like a switch. But better.

```rust
fn main() {
    let age = 13u32;
    match age {
        0...12 => println!("You may see G or PG movies"),
        13...16 => println!("You may see G, PG, or PG-13 movies"),
        _ => {
            println!("You are old.");
            println!("You may see G, PG, PG-13, or R movies")
        },
    }
}
```

???

* Underscore is catch-all
* Pattern, rocket, code to run
* Commas at the end of the code to run
* If the code is more than one line, surround with curly braces
* Trailing comma on the last one is the style
* What if we take out the line with the underscore? This is advantage to `match` over `if`/`else if`/`else`

---
class: middle, left

## Arrays

Kinda like arrays in other languages, but worse.

```rust
let mut color = [255, 0, 255];
color[0] = 100;
println!("The color is {:?}", color);
```

???

* Arrays are a fixed size known at compile time
* Square brackets, commas
* Indexing to a particular location
* Need debug formatting in println since Rust doesn't know how you want to display arrays to your users

---
class: middle, left

## Vectors

Most of the time, you probably want a vector rather than array.

```rust
let mut prices = vec![30, 100, 2];
prices[0] = 25;
prices.push(40);
println!("All the prices are: {:?}", prices);
```

???

* `vec!` shorthand macro, the rest is like an array
* Vecs can change in size at runtime
* So we can call the `push` method

---
class: middle, left

## Looping (and ranges)

* `for` loops are most common:

```rust
for i in 0..10 {
    println!("Number {}", i);
}
```

```rust
let names = vec!["Carol", "Jake", "Marylou", "Bruce"];
for name in names.iter() {
    println!("Hi {}!", name);
}
```

* `loop` creates an infinite loop
* `while` loops run while their condition is true
* `break` exits the current loop

---
class: middle, left

## Enums

* Nice to use with `match`

```rust
enum TrafficLight {
    Red,
    Yellow,
    Green,
}
let light = TrafficLight::Green;

match light {
    TrafficLight::Red => println!("STOP!"),
    TrafficLight::Yellow => println!("Slow down!"),
    TrafficLight::Green => println!("Go go go!"),
}
```

???

* Double colon is namespacing
* Show warnings!

---
class: middle, left

## Enums

* Better than in other languages: can hold values!

```rust
enum GameType {
    SinglePlayer,
    MultiPlayer(u32),
}

let game = GameType::MultiPlayer(4);

match game {
    GameType::SinglePlayer => println!("How about solitaire?"),
    GameType::MultiPlayer(2) => println!("How about checkers?"),
    GameType::MultiPlayer(4) => println!("How about bridge?"),
    GameType::MultiPlayer(num) => {
        println!("How about {}-player tag?", num)
    },
}
```

???

* Values are specific to each variant
* Have to define the type of the values in the variant
* Destructure = patterns that bind to parts
* Destructure to get values out

---
class: middle, left

## Concepts that are different than in other languages

---
class: middle, left

## Option

**Rust doesn't have `nil`/`null`** so to express that a value might be something or nothing, Rust has the `Option` type.

Option is an enum provided by the standard library:

```rust
enum Option<T> {
    Some(T),
    None
}
```

???

* T is a generic type parameter, means Some can hold any type
* No more undefined method on nil!!!!

---
class: middle, left

## Using Option

```rust
let mut instructors = vec!["Carol"];

let a = instructors.pop();
println!("a is {:?}", a);

let b = instructors.pop();
println!("b is {:?}", b);
```

???

* When we pop off the last element of a vec, there might not be one!

---
class: middle, left

## Using Option

```rust
let a = Some("Carol");

let name = a.expect("No name present");
println!("Name is {} bytes long", name.len());
```

???

* Can't call `len` on an `Option` directly since it could be `None`!
* expect crashes if it gets a None, good for prototyping or when you're REALLY REALLY SURE you have Some
    * Set an error message in expect that is useful to you for debugging
    * Try changing `a` to this and see what happens
        `let a: Option<&str> = None;`
    * Mention but gloss over type annotation

---
class: middle, left

## Using Option

```rust
let b: Option<&str> = None;

match b {
    Some(name) => {
        println!("Other name is {} bytes long", name.len())
    },
    None => {
        println!("No name!")
    }
}
```

???

* Match is useful for handling both cases
* Option is just another enum!

---
class: middle, left

## Result

* `expect`

---
class: middle, left

## Strings

Strings in Rust are a lot more complicated than you might be used to if
you are coming from another language, in particular, interpreted languages
like Ruby or JavaScript. Here's some key points:

#### `&str` and `String`
- "my string" is not a `String`. It's a `str`. the difference between a `String` and a
  `str` is how they are allocated. Don't worry about that right now.
- Pretty much always use `str` with an `&`, as `&str`.
- You can turn a `&str` into a `String` by using `to_string()` or `String::from()`. You want
to do this because `String` has a ton of awesome convenience methods.

---
class: middle, left

## Slices
---
class: middle, left

## Ownership
---
class: middle, left

## References

---
class: middle, left

## Features that make Rust super awesome

---
class: middle, left

## Crates
---
class: middle, left

## Iterators
---
class: middle, left

## Closures
---
class: middle, left

## Threads

---
class: middle, left

## Concepts we didn't cover but that are things
  * Tests
  * Lifetimes
  * Tuples
  * Structs
  * Methods
  * `if let`
  * FFI
  * Traits
  * Generics
  * Macros
  * Composition over inheritance

   </textarea>
    <script src="public/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
