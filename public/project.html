<DOCTYPE html>
<html>
  <head>
    <title>A Rust Project</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link href="skeleton.css" type="text/css" rel="stylesheet">
    <link href="custom.css" type="text/css" rel="stylesheet">
  </head>
  <body>
    <textarea id="source">

class: middle, center

![ferris](img/ferris.gif)

# Let's make a Rust project!!

---
class: middle, left

## Project: Web Scraper

* Problem: there's data on a website that you want to use, but getting it out of the website would be tedious and error-prone.
* Examples:
  * "open" data that isn't in an easy-to-use format
  * Branding Brand
  * Vivisimo

---
class: middle, left

## Overview

* Request an Amazon wishlist-like page and extract titles and prices
* Use an HTTP client library (`hyper`) to make the requests
* Use an HTML DOM parser (`select`) to extract the data
* Process the data using Iterators

---
class: middle, left

## Start a new project

* Go to wherever you keep your code
* `cargo new --bin web_scraper`
* `cd web_scraper`
* `cargo run`
* It should say "Hello, world!"
* Use version control however you'd like

---
class: middle, left

## Adding the `hyper` crate

* Edit `Cargo.toml` file
* Beneath `[dependencies]` section add `hyper = "0.9.10"` so it looks like:

```toml
[package]
name = "web_scraper"
version = "0.1.0"
authors = ["Carol (Nichols || Goulding) <carol.nichols@gmail.com>"]

[dependencies]
hyper = "0.9.10"
```

???

* A crate is a library that someone else made and shared, like rubygems
* How did we know to use hyper?
* Let's do `cargo run`!
* What else changed?

---
class: middle, left

## To the docs!

* `cargo doc --open`
* Click on "hyper" in the sidebar
* Click on "Client"
* `GET` example!

---
class: middle, left

## Using `hyper`

* Adding it to `Cargo.toml` just told cargo we wanted to have it available
* In `src/main.rs`, we can use the example from the docs with a few additions:

```rust
extern crate hyper;
use hyper::Client;

fn main() {
    let client = Client::new();

    let res = client.get("http://example.domain").send().expect("Request failed");
    assert_eq!(res.status, hyper::Ok);
    println!("{:#?}", response);
}
```

???

* `extern` brings the crate in
* `use` brings the name in scope; we could say `hyper::Client` everywhere instead
* Creating a new hyper::Client instance
* Variable res
* Result of calling `get` method on client, passing the address as an arg
* Show clicking on `Client` to get docs for that struct
* `get` returns a request builder
* `send` does the request
* Returns a `Result<Response>`
* Examples tend to use `unwrap` because it's short, but we're going to change it to `expect`
* This example does a test, basically-- assert_eq! will panic if it fails
* Let's run it with the clearly example address and see what happens!
* Let's run it with an address that will respond with a 404!
* Bonus, if you're bored: take the URL as a command line argument!
* Note that `hyper::Ok` is different than standard library `Ok`
* Talk about pretty debug output

---
class: middle, left

## How do we get the body of the `Response`?

* Look at the docs!
* "and the response body via the `Read` trait."

---
class: middle, left

## Traits

* Guarantees that a type implements a set of methods
  * Compiler-checked duck-typing
  * `implements` interfaces in Java

* Can define default methods in terms of required methods
  * Sort of like Ruby enumerable/each

* Display and Debug are traits you've been using!

---
class: middle, left

## The `Read` trait

* `impl Read for Response`
* We want to use the trait method `read_to_string`
* The trait needs to be in scope: `use std::io::Read;`

---
class: middle, left

```rust
extern crate hyper;

use hyper::Client;
use std::io::Read;

fn main() {
    let client = Client::new();
    let mut response =
        client.get("https://github.com")
              .send()
              .expect("Request failed");
    let mut body = String::new();
    response.read_to_string(&mut body).expect("Read failed");
    println!("{:?}", body);
}
```

???

* `response` needs to be `mut` now
* Need a mutable string to read into
* Pass a mutable reference to that string to `read_to_string`
* Then we get the HTML of github.com!

---
class: middle, left

## Get the content we're going to parse

* Change the URL to `https://brson.github.io/demo/wishlist.html`
* Take a look in your browser, it's basically an Amazon wishlist page
* Web devs: inspect element!

---
class: middle, left

## Another crate: `select`!

* Add to your `Cargo.toml`: `select = "0.3.0"`
* Rebuild the docs: `cargo doc --open`

---
class: middle, left




   </textarea>
    <script src="remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
